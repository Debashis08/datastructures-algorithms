name: deploy

# Triggers only when a PR to 'main' is closed
on:
  pull_request:
    types: [closed]
    branches:
      - 'main'

permissions:
  contents: write      # Required to push tags and create releases
  pull-requests: read  # Required to read PR body for checkboxes

jobs:
  # job 1: Deployment Validation
  # Verifies the PR is merged, comes from a release/* branch, and has a bump type.
  deployment-validation:
    runs-on: ubuntu-latest
    # Define outputs to pass to the next job
    outputs:
      bump_type: ${{ steps.get_bump_type.outputs.bump_type }}
      
    steps:
      - name: Verify Merge and Branch Policy
        run: |
          IS_MERGED="${{ github.event.pull_request.merged }}"
          HEAD_REF="${{ github.event.pull_request.head.ref }}"
          
          echo "PR Merged: $IS_MERGED"
          echo "Source Branch: $HEAD_REF"
          
          # 1. Check if PR was actually merged (not just closed)
          if [[ "$IS_MERGED" != "true" ]]; then
            echo "::notice::PR was closed without merging. Skipping release."
            exit 0
          fi

          # 2. Check if source branch starts with 'release/'
          if [[ "$HEAD_REF" != release/* ]]; then
            echo "::error::Invalid source branch. Releases must originate from 'release/*' branches."
            exit 1
          fi
          
          echo "Branch policy checks passed."

      - name: Determine Version Bump Type
        id: get_bump_type
        env:
          PR_BODY: ${{ github.event.pull_request.body }}
        run: |
          # Check checkboxes in PR Body: [x] Major, [x] Minor, etc.
          if echo "$PR_BODY" | grep -q '\[x\] Major'; then
            echo "bump_type=major" >> $GITHUB_OUTPUT
            echo "Detected bump: MAJOR"
          elif echo "$PR_BODY" | grep -q '\[x\] Minor'; then
            echo "bump_type=minor" >> $GITHUB_OUTPUT
            echo "Detected bump: MINOR"
          elif echo "$PR_BODY" | grep -q '\[x\] Patch'; then
            echo "bump_type=patch" >> $GITHUB_OUTPUT
            echo "Detected bump: PATCH"
          else
            echo "::error::No version bump detected. Please check [x] Major, [x] Minor, or [x] Patch in the PR body."
            exit 1
          fi

  # job 2: Create GitHub Tag and Release
  create-github-tag-and-release:
    needs: deployment-validation
    runs-on: ubuntu-latest
    env:
      BUMP_TYPE: ${{ needs.deployment-validation.outputs.bump_type }}
      
    steps:
      - name: Checkout main branch
        uses: actions/checkout@v4
        with:
          ref: 'main'
          fetch-depth: 0 # Crucial for calculating history/tags

      - name: Configure Git
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

      # Step A: Find the existing tag
      - name: Get Latest Tag
        id: get_latest_tag
        run: |
          # 1. Fetch all tags
          git fetch --tags
          
          # 2. Find latest tag (Sort by version number, take top)
          LATEST_TAG=$(git tag --list 'v*.*.*' --sort=-v:refname | head -n 1)
          
          if [ -z "$LATEST_TAG" ]; then
            echo "No previous tags found. Defaulting to v0.0.0"
            LATEST_TAG="v0.0.0"
          fi
          
          echo "Latest Tag: $LATEST_TAG"
          
          # Expose this variable to the next step
          echo "latest_tag=$LATEST_TAG" >> $GITHUB_OUTPUT

      # Step B: Do the math
      - name: Calculate New Tag
        id: calc_new_tag
        env:
          # Pull the tag from the previous step
          LATEST_TAG: ${{ steps.get_latest_tag.outputs.latest_tag }} 
          # Assuming BUMP_TYPE is set in the Job 'env' as per previous context
        run: |
          echo "Base Tag: $LATEST_TAG"
          echo "Bump Type: $BUMP_TYPE"
          
          # 1. Parse Version
          VERSION=${LATEST_TAG#v} # Remove 'v'
          IFS='.' read -r -a parts <<< "$VERSION"
          MAJOR=${parts[0]}
          MINOR=${parts[1]}
          PATCH=${parts[2]}
          
          # 2. Increment
          case "$BUMP_TYPE" in
            "major") MAJOR=$((MAJOR + 1)); MINOR=0; PATCH=0 ;;
            "minor") MINOR=$((MINOR + 1)); PATCH=0 ;;
            "patch") PATCH=$((PATCH + 1)) ;;
          esac
          
          NEW_TAG="v${MAJOR}.${MINOR}.${PATCH}"
          
          echo "new_tag=$NEW_TAG" >> $GITHUB_OUTPUT
          echo "New tag will be: $NEW_TAG"
      
      - name: Create and push new Git tag
        run: |
          NEW_TAG=${{ steps.calc_new_tag.outputs.new_tag }}
          MERGE_COMMIT_SHA=${{ github.event.pull_request.merge_commit_sha }}
          
          echo "Tagging commit $MERGE_COMMIT_SHA as $NEW_TAG"
          git tag $NEW_TAG $MERGE_COMMIT_SHA
          git push origin $NEW_TAG

      - name: Extract Release Summary
        id: extract_summary
        env:
          PR_BODY: ${{ github.event.pull_request.body }}
        run: |
          # Use an awk "state machine" to extract text between the two markers.
          # We use "<<<" (a "here string") to safely pass the multiline $PR_BODY to awk.
          # We must escape the '*' characters with '\' for the regex.
          
          # 1. /\*\*Release Summary\*\*/{f=1; next} : When we see the START marker, set flag 'f' to 1 and skip to the next line.
          # 2. /\*\*Version Bump Type\*\*/{f=0}      : When we see the END marker, set flag 'f' to 0.
          # 3. f                                 : If flag 'f' is 1 (true), print the current line.
          SUMMARY=$(awk '/\*\*Release Summary\*\*/{f=1; next} /\*\*Version Bump Type\*\*/{f=0} f' <<< "$PR_BODY")

          # Use multiline string syntax for GITHUB_OUTPUT
          echo "summary<<EOF" >> $GITHUB_OUTPUT
          echo "$SUMMARY" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Create GitHub Release
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          NEW_TAG: ${{ steps.calc_new_tag.outputs.new_tag }}
          NOTES: ${{ steps.extract_summary.outputs.summary }}
          TITLE: ${{ github.event.pull_request.title }}
        run: |
          # Default to PR title if notes are empty
          if [ -z "$NOTES" ]; then NOTES="$TITLE"; fi
          
          gh release create "$NEW_TAG" \
            --title "$NEW_TAG" \
            --notes "$NOTES" \
            --latest